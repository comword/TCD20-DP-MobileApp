// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: student.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_student_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_student_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_student_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_student_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace student {
class CommonGetRequest;
struct CommonGetRequestDefaultTypeInternal;
extern CommonGetRequestDefaultTypeInternal _CommonGetRequest_default_instance_;
class CommonGetResponse;
struct CommonGetResponseDefaultTypeInternal;
extern CommonGetResponseDefaultTypeInternal _CommonGetResponse_default_instance_;
class ExamDetail;
struct ExamDetailDefaultTypeInternal;
extern ExamDetailDefaultTypeInternal _ExamDetail_default_instance_;
class ExamDetail_AdditionInfoEntry_DoNotUse;
struct ExamDetail_AdditionInfoEntry_DoNotUseDefaultTypeInternal;
extern ExamDetail_AdditionInfoEntry_DoNotUseDefaultTypeInternal _ExamDetail_AdditionInfoEntry_DoNotUse_default_instance_;
class ExamResponse;
struct ExamResponseDefaultTypeInternal;
extern ExamResponseDefaultTypeInternal _ExamResponse_default_instance_;
class GetPredictRequest;
struct GetPredictRequestDefaultTypeInternal;
extern GetPredictRequestDefaultTypeInternal _GetPredictRequest_default_instance_;
class GetPredictResponse;
struct GetPredictResponseDefaultTypeInternal;
extern GetPredictResponseDefaultTypeInternal _GetPredictResponse_default_instance_;
class GetPredictResponse_ResultEntry_DoNotUse;
struct GetPredictResponse_ResultEntry_DoNotUseDefaultTypeInternal;
extern GetPredictResponse_ResultEntry_DoNotUseDefaultTypeInternal _GetPredictResponse_ResultEntry_DoNotUse_default_instance_;
class MetaData;
struct MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class ModelPredict;
struct ModelPredictDefaultTypeInternal;
extern ModelPredictDefaultTypeInternal _ModelPredict_default_instance_;
class ModelPredict_ResultEntry_DoNotUse;
struct ModelPredict_ResultEntry_DoNotUseDefaultTypeInternal;
extern ModelPredict_ResultEntry_DoNotUseDefaultTypeInternal _ModelPredict_ResultEntry_DoNotUse_default_instance_;
class StreamVideoRequest;
struct StreamVideoRequestDefaultTypeInternal;
extern StreamVideoRequestDefaultTypeInternal _StreamVideoRequest_default_instance_;
}  // namespace student
PROTOBUF_NAMESPACE_OPEN
template<> ::student::CommonGetRequest* Arena::CreateMaybeMessage<::student::CommonGetRequest>(Arena*);
template<> ::student::CommonGetResponse* Arena::CreateMaybeMessage<::student::CommonGetResponse>(Arena*);
template<> ::student::ExamDetail* Arena::CreateMaybeMessage<::student::ExamDetail>(Arena*);
template<> ::student::ExamDetail_AdditionInfoEntry_DoNotUse* Arena::CreateMaybeMessage<::student::ExamDetail_AdditionInfoEntry_DoNotUse>(Arena*);
template<> ::student::ExamResponse* Arena::CreateMaybeMessage<::student::ExamResponse>(Arena*);
template<> ::student::GetPredictRequest* Arena::CreateMaybeMessage<::student::GetPredictRequest>(Arena*);
template<> ::student::GetPredictResponse* Arena::CreateMaybeMessage<::student::GetPredictResponse>(Arena*);
template<> ::student::GetPredictResponse_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::student::GetPredictResponse_ResultEntry_DoNotUse>(Arena*);
template<> ::student::MetaData* Arena::CreateMaybeMessage<::student::MetaData>(Arena*);
template<> ::student::ModelPredict* Arena::CreateMaybeMessage<::student::ModelPredict>(Arena*);
template<> ::student::ModelPredict_ResultEntry_DoNotUse* Arena::CreateMaybeMessage<::student::ModelPredict_ResultEntry_DoNotUse>(Arena*);
template<> ::student::StreamVideoRequest* Arena::CreateMaybeMessage<::student::StreamVideoRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace student {

// ===================================================================

class CommonGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.CommonGetRequest) */ {
 public:
  inline CommonGetRequest() : CommonGetRequest(nullptr) {}
  ~CommonGetRequest() override;
  explicit constexpr CommonGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonGetRequest(const CommonGetRequest& from);
  CommonGetRequest(CommonGetRequest&& from) noexcept
    : CommonGetRequest() {
    *this = ::std::move(from);
  }

  inline CommonGetRequest& operator=(const CommonGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonGetRequest& operator=(CommonGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CommonGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonGetRequest* internal_default_instance() {
    return reinterpret_cast<const CommonGetRequest*>(
               &_CommonGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CommonGetRequest& a, CommonGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonGetRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonGetRequest* New() const final {
    return new CommonGetRequest();
  }

  CommonGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonGetRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommonGetRequest& from);
  void MergeFrom(const CommonGetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommonGetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.CommonGetRequest";
  }
  protected:
  explicit CommonGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_MUST_USE_RESULT std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:student.CommonGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class CommonGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.CommonGetResponse) */ {
 public:
  inline CommonGetResponse() : CommonGetResponse(nullptr) {}
  ~CommonGetResponse() override;
  explicit constexpr CommonGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonGetResponse(const CommonGetResponse& from);
  CommonGetResponse(CommonGetResponse&& from) noexcept
    : CommonGetResponse() {
    *this = ::std::move(from);
  }

  inline CommonGetResponse& operator=(const CommonGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonGetResponse& operator=(CommonGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CommonGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonGetResponse* internal_default_instance() {
    return reinterpret_cast<const CommonGetResponse*>(
               &_CommonGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CommonGetResponse& a, CommonGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonGetResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommonGetResponse* New() const final {
    return new CommonGetResponse();
  }

  CommonGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonGetResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommonGetResponse& from);
  void MergeFrom(const CommonGetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommonGetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.CommonGetResponse";
  }
  protected:
  explicit CommonGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:student.CommonGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class ExamDetail_AdditionInfoEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ExamDetail_AdditionInfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ExamDetail_AdditionInfoEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ExamDetail_AdditionInfoEntry_DoNotUse();
  explicit constexpr ExamDetail_AdditionInfoEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ExamDetail_AdditionInfoEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ExamDetail_AdditionInfoEntry_DoNotUse& other);
  static const ExamDetail_AdditionInfoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ExamDetail_AdditionInfoEntry_DoNotUse*>(&_ExamDetail_AdditionInfoEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "student.ExamDetail.AdditionInfoEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "student.ExamDetail.AdditionInfoEntry.value");
 }
};

// -------------------------------------------------------------------

class ExamDetail final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.ExamDetail) */ {
 public:
  inline ExamDetail() : ExamDetail(nullptr) {}
  ~ExamDetail() override;
  explicit constexpr ExamDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExamDetail(const ExamDetail& from);
  ExamDetail(ExamDetail&& from) noexcept
    : ExamDetail() {
    *this = ::std::move(from);
  }

  inline ExamDetail& operator=(const ExamDetail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExamDetail& operator=(ExamDetail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ExamDetail& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExamDetail* internal_default_instance() {
    return reinterpret_cast<const ExamDetail*>(
               &_ExamDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExamDetail& a, ExamDetail& b) {
    a.Swap(&b);
  }
  inline void Swap(ExamDetail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExamDetail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExamDetail* New() const final {
    return new ExamDetail();
  }

  ExamDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExamDetail>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExamDetail& from);
  void MergeFrom(const ExamDetail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExamDetail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.ExamDetail";
  }
  protected:
  explicit ExamDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAdditionInfoFieldNumber = 5,
    kPredictIdFieldNumber = 6,
    kExamIdFieldNumber = 1,
    kExamNameFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
  };
  // map<string, string> additionInfo = 5;
  int additioninfo_size() const;
  private:
  int _internal_additioninfo_size() const;
  public:
  void clear_additioninfo();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_additioninfo() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_additioninfo();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      additioninfo() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_additioninfo();

  // repeated string predictId = 6;
  int predictid_size() const;
  private:
  int _internal_predictid_size() const;
  public:
  void clear_predictid();
  const std::string& predictid(int index) const;
  std::string* mutable_predictid(int index);
  void set_predictid(int index, const std::string& value);
  void set_predictid(int index, std::string&& value);
  void set_predictid(int index, const char* value);
  void set_predictid(int index, const char* value, size_t size);
  std::string* add_predictid();
  void add_predictid(const std::string& value);
  void add_predictid(std::string&& value);
  void add_predictid(const char* value);
  void add_predictid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& predictid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_predictid();
  private:
  const std::string& _internal_predictid(int index) const;
  std::string* _internal_add_predictid();
  public:

  // string examId = 1;
  void clear_examid();
  const std::string& examid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_examid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_examid();
  PROTOBUF_MUST_USE_RESULT std::string* release_examid();
  void set_allocated_examid(std::string* examid);
  private:
  const std::string& _internal_examid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_examid(const std::string& value);
  std::string* _internal_mutable_examid();
  public:

  // string examName = 2;
  void clear_examname();
  const std::string& examname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_examname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_examname();
  PROTOBUF_MUST_USE_RESULT std::string* release_examname();
  void set_allocated_examname(std::string* examname);
  private:
  const std::string& _internal_examname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_examname(const std::string& value);
  std::string* _internal_mutable_examname();
  public:

  // .google.protobuf.Timestamp startTime = 3;
  bool has_starttime() const;
  private:
  bool _internal_has_starttime() const;
  public:
  void clear_starttime();
  const PROTOBUF_NAMESPACE_ID::Timestamp& starttime() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_starttime();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_starttime();
  void set_allocated_starttime(PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_starttime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_starttime();
  public:
  void unsafe_arena_set_allocated_starttime(
      PROTOBUF_NAMESPACE_ID::Timestamp* starttime);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_starttime();

  // .google.protobuf.Timestamp endTime = 4;
  bool has_endtime() const;
  private:
  bool _internal_has_endtime() const;
  public:
  void clear_endtime();
  const PROTOBUF_NAMESPACE_ID::Timestamp& endtime() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_endtime();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_endtime();
  void set_allocated_endtime(PROTOBUF_NAMESPACE_ID::Timestamp* endtime);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_endtime() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_endtime();
  public:
  void unsafe_arena_set_allocated_endtime(
      PROTOBUF_NAMESPACE_ID::Timestamp* endtime);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_endtime();

  // @@protoc_insertion_point(class_scope:student.ExamDetail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ExamDetail_AdditionInfoEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> additioninfo_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> predictid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr examid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr examname_;
  PROTOBUF_NAMESPACE_ID::Timestamp* starttime_;
  PROTOBUF_NAMESPACE_ID::Timestamp* endtime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class ExamResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.ExamResponse) */ {
 public:
  inline ExamResponse() : ExamResponse(nullptr) {}
  ~ExamResponse() override;
  explicit constexpr ExamResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExamResponse(const ExamResponse& from);
  ExamResponse(ExamResponse&& from) noexcept
    : ExamResponse() {
    *this = ::std::move(from);
  }

  inline ExamResponse& operator=(const ExamResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExamResponse& operator=(ExamResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ExamResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExamResponse* internal_default_instance() {
    return reinterpret_cast<const ExamResponse*>(
               &_ExamResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExamResponse& a, ExamResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExamResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExamResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExamResponse* New() const final {
    return new ExamResponse();
  }

  ExamResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExamResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ExamResponse& from);
  void MergeFrom(const ExamResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExamResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.ExamResponse";
  }
  protected:
  explicit ExamResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPendingExamsFieldNumber = 3,
    kPastExamsFieldNumber = 4,
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // repeated .student.ExamDetail pendingExams = 3;
  int pendingexams_size() const;
  private:
  int _internal_pendingexams_size() const;
  public:
  void clear_pendingexams();
  ::student::ExamDetail* mutable_pendingexams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >*
      mutable_pendingexams();
  private:
  const ::student::ExamDetail& _internal_pendingexams(int index) const;
  ::student::ExamDetail* _internal_add_pendingexams();
  public:
  const ::student::ExamDetail& pendingexams(int index) const;
  ::student::ExamDetail* add_pendingexams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >&
      pendingexams() const;

  // repeated .student.ExamDetail pastExams = 4;
  int pastexams_size() const;
  private:
  int _internal_pastexams_size() const;
  public:
  void clear_pastexams();
  ::student::ExamDetail* mutable_pastexams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >*
      mutable_pastexams();
  private:
  const ::student::ExamDetail& _internal_pastexams(int index) const;
  ::student::ExamDetail* _internal_add_pastexams();
  public:
  const ::student::ExamDetail& pastexams(int index) const;
  ::student::ExamDetail* add_pastexams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >&
      pastexams() const;

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:student.ExamResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail > pendingexams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail > pastexams_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class ModelPredict_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ModelPredict_ResultEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<ModelPredict_ResultEntry_DoNotUse, 
    std::string, float,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> SuperType;
  ModelPredict_ResultEntry_DoNotUse();
  explicit constexpr ModelPredict_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ModelPredict_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ModelPredict_ResultEntry_DoNotUse& other);
  static const ModelPredict_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ModelPredict_ResultEntry_DoNotUse*>(&_ModelPredict_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "student.ModelPredict.ResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class ModelPredict final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.ModelPredict) */ {
 public:
  inline ModelPredict() : ModelPredict(nullptr) {}
  ~ModelPredict() override;
  explicit constexpr ModelPredict(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelPredict(const ModelPredict& from);
  ModelPredict(ModelPredict&& from) noexcept
    : ModelPredict() {
    *this = ::std::move(from);
  }

  inline ModelPredict& operator=(const ModelPredict& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelPredict& operator=(ModelPredict&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ModelPredict& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelPredict* internal_default_instance() {
    return reinterpret_cast<const ModelPredict*>(
               &_ModelPredict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ModelPredict& a, ModelPredict& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelPredict* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelPredict* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelPredict* New() const final {
    return new ModelPredict();
  }

  ModelPredict* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelPredict>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelPredict& from);
  void MergeFrom(const ModelPredict& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelPredict* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.ModelPredict";
  }
  protected:
  explicit ModelPredict(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 4,
    kExamIdFieldNumber = 1,
    kStudentIdFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // map<string, float> result = 4;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
      mutable_result();

  // string examId = 1;
  void clear_examid();
  const std::string& examid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_examid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_examid();
  PROTOBUF_MUST_USE_RESULT std::string* release_examid();
  void set_allocated_examid(std::string* examid);
  private:
  const std::string& _internal_examid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_examid(const std::string& value);
  std::string* _internal_mutable_examid();
  public:

  // string studentId = 2;
  void clear_studentid();
  const std::string& studentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_studentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_studentid();
  PROTOBUF_MUST_USE_RESULT std::string* release_studentid();
  void set_allocated_studentid(std::string* studentid);
  private:
  const std::string& _internal_studentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_studentid(const std::string& value);
  std::string* _internal_mutable_studentid();
  public:

  // .google.protobuf.Timestamp time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& time() const;
  PROTOBUF_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::Timestamp* release_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_time();
  void set_allocated_time(PROTOBUF_NAMESPACE_ID::Timestamp* time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_time();

  // @@protoc_insertion_point(class_scope:student.ModelPredict)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      ModelPredict_ResultEntry_DoNotUse,
      std::string, float,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT> result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr examid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr studentid_;
  PROTOBUF_NAMESPACE_ID::Timestamp* time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class GetPredictRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.GetPredictRequest) */ {
 public:
  inline GetPredictRequest() : GetPredictRequest(nullptr) {}
  ~GetPredictRequest() override;
  explicit constexpr GetPredictRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPredictRequest(const GetPredictRequest& from);
  GetPredictRequest(GetPredictRequest&& from) noexcept
    : GetPredictRequest() {
    *this = ::std::move(from);
  }

  inline GetPredictRequest& operator=(const GetPredictRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPredictRequest& operator=(GetPredictRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const GetPredictRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPredictRequest* internal_default_instance() {
    return reinterpret_cast<const GetPredictRequest*>(
               &_GetPredictRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetPredictRequest& a, GetPredictRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPredictRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPredictRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPredictRequest* New() const final {
    return new GetPredictRequest();
  }

  GetPredictRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPredictRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetPredictRequest& from);
  void MergeFrom(const GetPredictRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetPredictRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.GetPredictRequest";
  }
  protected:
  explicit GetPredictRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredictIdFieldNumber = 1,
  };
  // repeated string predictId = 1;
  int predictid_size() const;
  private:
  int _internal_predictid_size() const;
  public:
  void clear_predictid();
  const std::string& predictid(int index) const;
  std::string* mutable_predictid(int index);
  void set_predictid(int index, const std::string& value);
  void set_predictid(int index, std::string&& value);
  void set_predictid(int index, const char* value);
  void set_predictid(int index, const char* value, size_t size);
  std::string* add_predictid();
  void add_predictid(const std::string& value);
  void add_predictid(std::string&& value);
  void add_predictid(const char* value);
  void add_predictid(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& predictid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_predictid();
  private:
  const std::string& _internal_predictid(int index) const;
  std::string* _internal_add_predictid();
  public:

  // @@protoc_insertion_point(class_scope:student.GetPredictRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> predictid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class GetPredictResponse_ResultEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<GetPredictResponse_ResultEntry_DoNotUse, 
    std::string, ::student::ModelPredict,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<GetPredictResponse_ResultEntry_DoNotUse, 
    std::string, ::student::ModelPredict,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  GetPredictResponse_ResultEntry_DoNotUse();
  explicit constexpr GetPredictResponse_ResultEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetPredictResponse_ResultEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetPredictResponse_ResultEntry_DoNotUse& other);
  static const GetPredictResponse_ResultEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetPredictResponse_ResultEntry_DoNotUse*>(&_GetPredictResponse_ResultEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "student.GetPredictResponse.ResultEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
};

// -------------------------------------------------------------------

class GetPredictResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.GetPredictResponse) */ {
 public:
  inline GetPredictResponse() : GetPredictResponse(nullptr) {}
  ~GetPredictResponse() override;
  explicit constexpr GetPredictResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPredictResponse(const GetPredictResponse& from);
  GetPredictResponse(GetPredictResponse&& from) noexcept
    : GetPredictResponse() {
    *this = ::std::move(from);
  }

  inline GetPredictResponse& operator=(const GetPredictResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPredictResponse& operator=(GetPredictResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const GetPredictResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPredictResponse* internal_default_instance() {
    return reinterpret_cast<const GetPredictResponse*>(
               &_GetPredictResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetPredictResponse& a, GetPredictResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPredictResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPredictResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPredictResponse* New() const final {
    return new GetPredictResponse();
  }

  GetPredictResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPredictResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetPredictResponse& from);
  void MergeFrom(const GetPredictResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetPredictResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.GetPredictResponse";
  }
  protected:
  explicit GetPredictResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 3,
    kMsgFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // map<string, .student.ModelPredict> result = 3;
  int result_size() const;
  private:
  int _internal_result_size() const;
  public:
  void clear_result();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >&
      _internal_result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >*
      _internal_mutable_result();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >&
      result() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >*
      mutable_result();

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_MUST_USE_RESULT std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:student.GetPredictResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      GetPredictResponse_ResultEntry_DoNotUse,
      std::string, ::student::ModelPredict,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> result_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class MetaData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.MetaData) */ {
 public:
  inline MetaData() : MetaData(nullptr) {}
  ~MetaData() override;
  explicit constexpr MetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaData(const MetaData& from);
  MetaData(MetaData&& from) noexcept
    : MetaData() {
    *this = ::std::move(from);
  }

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaData& operator=(MetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MetaData& a, MetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaData* New() const final {
    return new MetaData();
  }

  MetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MetaData& from);
  void MergeFrom(const MetaData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MetaData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.MetaData";
  }
  protected:
  explicit MetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExamIdFieldNumber = 1,
  };
  // string examId = 1;
  void clear_examid();
  const std::string& examid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_examid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_examid();
  PROTOBUF_MUST_USE_RESULT std::string* release_examid();
  void set_allocated_examid(std::string* examid);
  private:
  const std::string& _internal_examid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_examid(const std::string& value);
  std::string* _internal_mutable_examid();
  public:

  // @@protoc_insertion_point(class_scope:student.MetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr examid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_student_2eproto;
};
// -------------------------------------------------------------------

class StreamVideoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:student.StreamVideoRequest) */ {
 public:
  inline StreamVideoRequest() : StreamVideoRequest(nullptr) {}
  ~StreamVideoRequest() override;
  explicit constexpr StreamVideoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamVideoRequest(const StreamVideoRequest& from);
  StreamVideoRequest(StreamVideoRequest&& from) noexcept
    : StreamVideoRequest() {
    *this = ::std::move(from);
  }

  inline StreamVideoRequest& operator=(const StreamVideoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamVideoRequest& operator=(StreamVideoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StreamVideoRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kMetadata = 1,
    kChunkdata = 2,
    REQUEST_NOT_SET = 0,
  };

  static inline const StreamVideoRequest* internal_default_instance() {
    return reinterpret_cast<const StreamVideoRequest*>(
               &_StreamVideoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StreamVideoRequest& a, StreamVideoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamVideoRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamVideoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamVideoRequest* New() const final {
    return new StreamVideoRequest();
  }

  StreamVideoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamVideoRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreamVideoRequest& from);
  void MergeFrom(const StreamVideoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamVideoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "student.StreamVideoRequest";
  }
  protected:
  explicit StreamVideoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 1,
    kChunkdataFieldNumber = 2,
  };
  // .student.MetaData metadata = 1;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::student::MetaData& metadata() const;
  PROTOBUF_MUST_USE_RESULT ::student::MetaData* release_metadata();
  ::student::MetaData* mutable_metadata();
  void set_allocated_metadata(::student::MetaData* metadata);
  private:
  const ::student::MetaData& _internal_metadata() const;
  ::student::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::student::MetaData* metadata);
  ::student::MetaData* unsafe_arena_release_metadata();

  // bytes chunkdata = 2;
  bool has_chunkdata() const;
  private:
  bool _internal_has_chunkdata() const;
  public:
  void clear_chunkdata();
  const std::string& chunkdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunkdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunkdata();
  PROTOBUF_MUST_USE_RESULT std::string* release_chunkdata();
  void set_allocated_chunkdata(std::string* chunkdata);
  private:
  const std::string& _internal_chunkdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunkdata(const std::string& value);
  std::string* _internal_mutable_chunkdata();
  public:

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:student.StreamVideoRequest)
 private:
  class _Internal;
  void set_has_metadata();
  void set_has_chunkdata();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::student::MetaData* metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunkdata_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_student_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CommonGetRequest

// string content = 1;
inline void CommonGetRequest::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& CommonGetRequest::content() const {
  // @@protoc_insertion_point(field_get:student.CommonGetRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonGetRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.CommonGetRequest.content)
}
inline std::string* CommonGetRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:student.CommonGetRequest.content)
  return _s;
}
inline const std::string& CommonGetRequest::_internal_content() const {
  return content_.Get();
}
inline void CommonGetRequest::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonGetRequest::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonGetRequest::release_content() {
  // @@protoc_insertion_point(field_release:student.CommonGetRequest.content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommonGetRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.CommonGetRequest.content)
}

// -------------------------------------------------------------------

// CommonGetResponse

// int32 code = 1;
inline void CommonGetResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommonGetResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommonGetResponse::code() const {
  // @@protoc_insertion_point(field_get:student.CommonGetResponse.code)
  return _internal_code();
}
inline void CommonGetResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void CommonGetResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:student.CommonGetResponse.code)
}

// string msg = 2;
inline void CommonGetResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& CommonGetResponse::msg() const {
  // @@protoc_insertion_point(field_get:student.CommonGetResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonGetResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.CommonGetResponse.msg)
}
inline std::string* CommonGetResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:student.CommonGetResponse.msg)
  return _s;
}
inline const std::string& CommonGetResponse::_internal_msg() const {
  return msg_.Get();
}
inline void CommonGetResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CommonGetResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CommonGetResponse::release_msg() {
  // @@protoc_insertion_point(field_release:student.CommonGetResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CommonGetResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.CommonGetResponse.msg)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExamDetail

// string examId = 1;
inline void ExamDetail::clear_examid() {
  examid_.ClearToEmpty();
}
inline const std::string& ExamDetail::examid() const {
  // @@protoc_insertion_point(field_get:student.ExamDetail.examId)
  return _internal_examid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExamDetail::set_examid(ArgT0&& arg0, ArgT... args) {
 
 examid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.ExamDetail.examId)
}
inline std::string* ExamDetail::mutable_examid() {
  std::string* _s = _internal_mutable_examid();
  // @@protoc_insertion_point(field_mutable:student.ExamDetail.examId)
  return _s;
}
inline const std::string& ExamDetail::_internal_examid() const {
  return examid_.Get();
}
inline void ExamDetail::_internal_set_examid(const std::string& value) {
  
  examid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExamDetail::_internal_mutable_examid() {
  
  return examid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExamDetail::release_examid() {
  // @@protoc_insertion_point(field_release:student.ExamDetail.examId)
  return examid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExamDetail::set_allocated_examid(std::string* examid) {
  if (examid != nullptr) {
    
  } else {
    
  }
  examid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), examid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.ExamDetail.examId)
}

// string examName = 2;
inline void ExamDetail::clear_examname() {
  examname_.ClearToEmpty();
}
inline const std::string& ExamDetail::examname() const {
  // @@protoc_insertion_point(field_get:student.ExamDetail.examName)
  return _internal_examname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExamDetail::set_examname(ArgT0&& arg0, ArgT... args) {
 
 examname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.ExamDetail.examName)
}
inline std::string* ExamDetail::mutable_examname() {
  std::string* _s = _internal_mutable_examname();
  // @@protoc_insertion_point(field_mutable:student.ExamDetail.examName)
  return _s;
}
inline const std::string& ExamDetail::_internal_examname() const {
  return examname_.Get();
}
inline void ExamDetail::_internal_set_examname(const std::string& value) {
  
  examname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExamDetail::_internal_mutable_examname() {
  
  return examname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExamDetail::release_examname() {
  // @@protoc_insertion_point(field_release:student.ExamDetail.examName)
  return examname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExamDetail::set_allocated_examname(std::string* examname) {
  if (examname != nullptr) {
    
  } else {
    
  }
  examname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), examname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.ExamDetail.examName)
}

// .google.protobuf.Timestamp startTime = 3;
inline bool ExamDetail::_internal_has_starttime() const {
  return this != internal_default_instance() && starttime_ != nullptr;
}
inline bool ExamDetail::has_starttime() const {
  return _internal_has_starttime();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ExamDetail::_internal_starttime() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = starttime_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ExamDetail::starttime() const {
  // @@protoc_insertion_point(field_get:student.ExamDetail.startTime)
  return _internal_starttime();
}
inline void ExamDetail::unsafe_arena_set_allocated_starttime(
    PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  starttime_ = starttime;
  if (starttime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:student.ExamDetail.startTime)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::release_starttime() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::unsafe_arena_release_starttime() {
  // @@protoc_insertion_point(field_release:student.ExamDetail.startTime)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = starttime_;
  starttime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::_internal_mutable_starttime() {
  
  if (starttime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    starttime_ = p;
  }
  return starttime_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::mutable_starttime() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_starttime();
  // @@protoc_insertion_point(field_mutable:student.ExamDetail.startTime)
  return _msg;
}
inline void ExamDetail::set_allocated_starttime(PROTOBUF_NAMESPACE_ID::Timestamp* starttime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime_);
  }
  if (starttime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(starttime));
    if (message_arena != submessage_arena) {
      starttime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, starttime, submessage_arena);
    }
    
  } else {
    
  }
  starttime_ = starttime;
  // @@protoc_insertion_point(field_set_allocated:student.ExamDetail.startTime)
}

// .google.protobuf.Timestamp endTime = 4;
inline bool ExamDetail::_internal_has_endtime() const {
  return this != internal_default_instance() && endtime_ != nullptr;
}
inline bool ExamDetail::has_endtime() const {
  return _internal_has_endtime();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ExamDetail::_internal_endtime() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = endtime_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ExamDetail::endtime() const {
  // @@protoc_insertion_point(field_get:student.ExamDetail.endTime)
  return _internal_endtime();
}
inline void ExamDetail::unsafe_arena_set_allocated_endtime(
    PROTOBUF_NAMESPACE_ID::Timestamp* endtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  endtime_ = endtime;
  if (endtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:student.ExamDetail.endTime)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::release_endtime() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = endtime_;
  endtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::unsafe_arena_release_endtime() {
  // @@protoc_insertion_point(field_release:student.ExamDetail.endTime)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = endtime_;
  endtime_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::_internal_mutable_endtime() {
  
  if (endtime_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    endtime_ = p;
  }
  return endtime_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ExamDetail::mutable_endtime() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_endtime();
  // @@protoc_insertion_point(field_mutable:student.ExamDetail.endTime)
  return _msg;
}
inline void ExamDetail::set_allocated_endtime(PROTOBUF_NAMESPACE_ID::Timestamp* endtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime_);
  }
  if (endtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endtime));
    if (message_arena != submessage_arena) {
      endtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endtime, submessage_arena);
    }
    
  } else {
    
  }
  endtime_ = endtime;
  // @@protoc_insertion_point(field_set_allocated:student.ExamDetail.endTime)
}

// map<string, string> additionInfo = 5;
inline int ExamDetail::_internal_additioninfo_size() const {
  return additioninfo_.size();
}
inline int ExamDetail::additioninfo_size() const {
  return _internal_additioninfo_size();
}
inline void ExamDetail::clear_additioninfo() {
  additioninfo_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExamDetail::_internal_additioninfo() const {
  return additioninfo_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ExamDetail::additioninfo() const {
  // @@protoc_insertion_point(field_map:student.ExamDetail.additionInfo)
  return _internal_additioninfo();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExamDetail::_internal_mutable_additioninfo() {
  return additioninfo_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ExamDetail::mutable_additioninfo() {
  // @@protoc_insertion_point(field_mutable_map:student.ExamDetail.additionInfo)
  return _internal_mutable_additioninfo();
}

// repeated string predictId = 6;
inline int ExamDetail::_internal_predictid_size() const {
  return predictid_.size();
}
inline int ExamDetail::predictid_size() const {
  return _internal_predictid_size();
}
inline void ExamDetail::clear_predictid() {
  predictid_.Clear();
}
inline std::string* ExamDetail::add_predictid() {
  std::string* _s = _internal_add_predictid();
  // @@protoc_insertion_point(field_add_mutable:student.ExamDetail.predictId)
  return _s;
}
inline const std::string& ExamDetail::_internal_predictid(int index) const {
  return predictid_.Get(index);
}
inline const std::string& ExamDetail::predictid(int index) const {
  // @@protoc_insertion_point(field_get:student.ExamDetail.predictId)
  return _internal_predictid(index);
}
inline std::string* ExamDetail::mutable_predictid(int index) {
  // @@protoc_insertion_point(field_mutable:student.ExamDetail.predictId)
  return predictid_.Mutable(index);
}
inline void ExamDetail::set_predictid(int index, const std::string& value) {
  predictid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:student.ExamDetail.predictId)
}
inline void ExamDetail::set_predictid(int index, std::string&& value) {
  predictid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:student.ExamDetail.predictId)
}
inline void ExamDetail::set_predictid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  predictid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:student.ExamDetail.predictId)
}
inline void ExamDetail::set_predictid(int index, const char* value, size_t size) {
  predictid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:student.ExamDetail.predictId)
}
inline std::string* ExamDetail::_internal_add_predictid() {
  return predictid_.Add();
}
inline void ExamDetail::add_predictid(const std::string& value) {
  predictid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:student.ExamDetail.predictId)
}
inline void ExamDetail::add_predictid(std::string&& value) {
  predictid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:student.ExamDetail.predictId)
}
inline void ExamDetail::add_predictid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  predictid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:student.ExamDetail.predictId)
}
inline void ExamDetail::add_predictid(const char* value, size_t size) {
  predictid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:student.ExamDetail.predictId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExamDetail::predictid() const {
  // @@protoc_insertion_point(field_list:student.ExamDetail.predictId)
  return predictid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExamDetail::mutable_predictid() {
  // @@protoc_insertion_point(field_mutable_list:student.ExamDetail.predictId)
  return &predictid_;
}

// -------------------------------------------------------------------

// ExamResponse

// int32 code = 1;
inline void ExamResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExamResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExamResponse::code() const {
  // @@protoc_insertion_point(field_get:student.ExamResponse.code)
  return _internal_code();
}
inline void ExamResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void ExamResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:student.ExamResponse.code)
}

// string msg = 2;
inline void ExamResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& ExamResponse::msg() const {
  // @@protoc_insertion_point(field_get:student.ExamResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExamResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.ExamResponse.msg)
}
inline std::string* ExamResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:student.ExamResponse.msg)
  return _s;
}
inline const std::string& ExamResponse::_internal_msg() const {
  return msg_.Get();
}
inline void ExamResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExamResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExamResponse::release_msg() {
  // @@protoc_insertion_point(field_release:student.ExamResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExamResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.ExamResponse.msg)
}

// repeated .student.ExamDetail pendingExams = 3;
inline int ExamResponse::_internal_pendingexams_size() const {
  return pendingexams_.size();
}
inline int ExamResponse::pendingexams_size() const {
  return _internal_pendingexams_size();
}
inline void ExamResponse::clear_pendingexams() {
  pendingexams_.Clear();
}
inline ::student::ExamDetail* ExamResponse::mutable_pendingexams(int index) {
  // @@protoc_insertion_point(field_mutable:student.ExamResponse.pendingExams)
  return pendingexams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >*
ExamResponse::mutable_pendingexams() {
  // @@protoc_insertion_point(field_mutable_list:student.ExamResponse.pendingExams)
  return &pendingexams_;
}
inline const ::student::ExamDetail& ExamResponse::_internal_pendingexams(int index) const {
  return pendingexams_.Get(index);
}
inline const ::student::ExamDetail& ExamResponse::pendingexams(int index) const {
  // @@protoc_insertion_point(field_get:student.ExamResponse.pendingExams)
  return _internal_pendingexams(index);
}
inline ::student::ExamDetail* ExamResponse::_internal_add_pendingexams() {
  return pendingexams_.Add();
}
inline ::student::ExamDetail* ExamResponse::add_pendingexams() {
  ::student::ExamDetail* _add = _internal_add_pendingexams();
  // @@protoc_insertion_point(field_add:student.ExamResponse.pendingExams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >&
ExamResponse::pendingexams() const {
  // @@protoc_insertion_point(field_list:student.ExamResponse.pendingExams)
  return pendingexams_;
}

// repeated .student.ExamDetail pastExams = 4;
inline int ExamResponse::_internal_pastexams_size() const {
  return pastexams_.size();
}
inline int ExamResponse::pastexams_size() const {
  return _internal_pastexams_size();
}
inline void ExamResponse::clear_pastexams() {
  pastexams_.Clear();
}
inline ::student::ExamDetail* ExamResponse::mutable_pastexams(int index) {
  // @@protoc_insertion_point(field_mutable:student.ExamResponse.pastExams)
  return pastexams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >*
ExamResponse::mutable_pastexams() {
  // @@protoc_insertion_point(field_mutable_list:student.ExamResponse.pastExams)
  return &pastexams_;
}
inline const ::student::ExamDetail& ExamResponse::_internal_pastexams(int index) const {
  return pastexams_.Get(index);
}
inline const ::student::ExamDetail& ExamResponse::pastexams(int index) const {
  // @@protoc_insertion_point(field_get:student.ExamResponse.pastExams)
  return _internal_pastexams(index);
}
inline ::student::ExamDetail* ExamResponse::_internal_add_pastexams() {
  return pastexams_.Add();
}
inline ::student::ExamDetail* ExamResponse::add_pastexams() {
  ::student::ExamDetail* _add = _internal_add_pastexams();
  // @@protoc_insertion_point(field_add:student.ExamResponse.pastExams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::student::ExamDetail >&
ExamResponse::pastexams() const {
  // @@protoc_insertion_point(field_list:student.ExamResponse.pastExams)
  return pastexams_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ModelPredict

// string examId = 1;
inline void ModelPredict::clear_examid() {
  examid_.ClearToEmpty();
}
inline const std::string& ModelPredict::examid() const {
  // @@protoc_insertion_point(field_get:student.ModelPredict.examId)
  return _internal_examid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelPredict::set_examid(ArgT0&& arg0, ArgT... args) {
 
 examid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.ModelPredict.examId)
}
inline std::string* ModelPredict::mutable_examid() {
  std::string* _s = _internal_mutable_examid();
  // @@protoc_insertion_point(field_mutable:student.ModelPredict.examId)
  return _s;
}
inline const std::string& ModelPredict::_internal_examid() const {
  return examid_.Get();
}
inline void ModelPredict::_internal_set_examid(const std::string& value) {
  
  examid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModelPredict::_internal_mutable_examid() {
  
  return examid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModelPredict::release_examid() {
  // @@protoc_insertion_point(field_release:student.ModelPredict.examId)
  return examid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModelPredict::set_allocated_examid(std::string* examid) {
  if (examid != nullptr) {
    
  } else {
    
  }
  examid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), examid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.ModelPredict.examId)
}

// string studentId = 2;
inline void ModelPredict::clear_studentid() {
  studentid_.ClearToEmpty();
}
inline const std::string& ModelPredict::studentid() const {
  // @@protoc_insertion_point(field_get:student.ModelPredict.studentId)
  return _internal_studentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelPredict::set_studentid(ArgT0&& arg0, ArgT... args) {
 
 studentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.ModelPredict.studentId)
}
inline std::string* ModelPredict::mutable_studentid() {
  std::string* _s = _internal_mutable_studentid();
  // @@protoc_insertion_point(field_mutable:student.ModelPredict.studentId)
  return _s;
}
inline const std::string& ModelPredict::_internal_studentid() const {
  return studentid_.Get();
}
inline void ModelPredict::_internal_set_studentid(const std::string& value) {
  
  studentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ModelPredict::_internal_mutable_studentid() {
  
  return studentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ModelPredict::release_studentid() {
  // @@protoc_insertion_point(field_release:student.ModelPredict.studentId)
  return studentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ModelPredict::set_allocated_studentid(std::string* studentid) {
  if (studentid != nullptr) {
    
  } else {
    
  }
  studentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), studentid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.ModelPredict.studentId)
}

// .google.protobuf.Timestamp time = 3;
inline bool ModelPredict::_internal_has_time() const {
  return this != internal_default_instance() && time_ != nullptr;
}
inline bool ModelPredict::has_time() const {
  return _internal_has_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ModelPredict::_internal_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = time_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp&>(
      PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& ModelPredict::time() const {
  // @@protoc_insertion_point(field_get:student.ModelPredict.time)
  return _internal_time();
}
inline void ModelPredict::unsafe_arena_set_allocated_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:student.ModelPredict.time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ModelPredict::release_time() {
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ModelPredict::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_release:student.ModelPredict.time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = time_;
  time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ModelPredict::_internal_mutable_time() {
  
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    time_ = p;
  }
  return time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* ModelPredict::mutable_time() {
  PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:student.ModelPredict.time)
  return _msg;
}
inline void ModelPredict::set_allocated_time(PROTOBUF_NAMESPACE_ID::Timestamp* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(time));
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    
  } else {
    
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:student.ModelPredict.time)
}

// map<string, float> result = 4;
inline int ModelPredict::_internal_result_size() const {
  return result_.size();
}
inline int ModelPredict::result_size() const {
  return _internal_result_size();
}
inline void ModelPredict::clear_result() {
  result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
ModelPredict::_internal_result() const {
  return result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >&
ModelPredict::result() const {
  // @@protoc_insertion_point(field_map:student.ModelPredict.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
ModelPredict::_internal_mutable_result() {
  return result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, float >*
ModelPredict::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:student.ModelPredict.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// GetPredictRequest

// repeated string predictId = 1;
inline int GetPredictRequest::_internal_predictid_size() const {
  return predictid_.size();
}
inline int GetPredictRequest::predictid_size() const {
  return _internal_predictid_size();
}
inline void GetPredictRequest::clear_predictid() {
  predictid_.Clear();
}
inline std::string* GetPredictRequest::add_predictid() {
  std::string* _s = _internal_add_predictid();
  // @@protoc_insertion_point(field_add_mutable:student.GetPredictRequest.predictId)
  return _s;
}
inline const std::string& GetPredictRequest::_internal_predictid(int index) const {
  return predictid_.Get(index);
}
inline const std::string& GetPredictRequest::predictid(int index) const {
  // @@protoc_insertion_point(field_get:student.GetPredictRequest.predictId)
  return _internal_predictid(index);
}
inline std::string* GetPredictRequest::mutable_predictid(int index) {
  // @@protoc_insertion_point(field_mutable:student.GetPredictRequest.predictId)
  return predictid_.Mutable(index);
}
inline void GetPredictRequest::set_predictid(int index, const std::string& value) {
  predictid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:student.GetPredictRequest.predictId)
}
inline void GetPredictRequest::set_predictid(int index, std::string&& value) {
  predictid_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:student.GetPredictRequest.predictId)
}
inline void GetPredictRequest::set_predictid(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  predictid_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:student.GetPredictRequest.predictId)
}
inline void GetPredictRequest::set_predictid(int index, const char* value, size_t size) {
  predictid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:student.GetPredictRequest.predictId)
}
inline std::string* GetPredictRequest::_internal_add_predictid() {
  return predictid_.Add();
}
inline void GetPredictRequest::add_predictid(const std::string& value) {
  predictid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:student.GetPredictRequest.predictId)
}
inline void GetPredictRequest::add_predictid(std::string&& value) {
  predictid_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:student.GetPredictRequest.predictId)
}
inline void GetPredictRequest::add_predictid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  predictid_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:student.GetPredictRequest.predictId)
}
inline void GetPredictRequest::add_predictid(const char* value, size_t size) {
  predictid_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:student.GetPredictRequest.predictId)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetPredictRequest::predictid() const {
  // @@protoc_insertion_point(field_list:student.GetPredictRequest.predictId)
  return predictid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetPredictRequest::mutable_predictid() {
  // @@protoc_insertion_point(field_mutable_list:student.GetPredictRequest.predictId)
  return &predictid_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetPredictResponse

// int32 code = 1;
inline void GetPredictResponse::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetPredictResponse::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetPredictResponse::code() const {
  // @@protoc_insertion_point(field_get:student.GetPredictResponse.code)
  return _internal_code();
}
inline void GetPredictResponse::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void GetPredictResponse::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:student.GetPredictResponse.code)
}

// string msg = 2;
inline void GetPredictResponse::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& GetPredictResponse::msg() const {
  // @@protoc_insertion_point(field_get:student.GetPredictResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPredictResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.GetPredictResponse.msg)
}
inline std::string* GetPredictResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:student.GetPredictResponse.msg)
  return _s;
}
inline const std::string& GetPredictResponse::_internal_msg() const {
  return msg_.Get();
}
inline void GetPredictResponse::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPredictResponse::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPredictResponse::release_msg() {
  // @@protoc_insertion_point(field_release:student.GetPredictResponse.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPredictResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.GetPredictResponse.msg)
}

// map<string, .student.ModelPredict> result = 3;
inline int GetPredictResponse::_internal_result_size() const {
  return result_.size();
}
inline int GetPredictResponse::result_size() const {
  return _internal_result_size();
}
inline void GetPredictResponse::clear_result() {
  result_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >&
GetPredictResponse::_internal_result() const {
  return result_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >&
GetPredictResponse::result() const {
  // @@protoc_insertion_point(field_map:student.GetPredictResponse.result)
  return _internal_result();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >*
GetPredictResponse::_internal_mutable_result() {
  return result_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::student::ModelPredict >*
GetPredictResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_map:student.GetPredictResponse.result)
  return _internal_mutable_result();
}

// -------------------------------------------------------------------

// MetaData

// string examId = 1;
inline void MetaData::clear_examid() {
  examid_.ClearToEmpty();
}
inline const std::string& MetaData::examid() const {
  // @@protoc_insertion_point(field_get:student.MetaData.examId)
  return _internal_examid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetaData::set_examid(ArgT0&& arg0, ArgT... args) {
 
 examid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.MetaData.examId)
}
inline std::string* MetaData::mutable_examid() {
  std::string* _s = _internal_mutable_examid();
  // @@protoc_insertion_point(field_mutable:student.MetaData.examId)
  return _s;
}
inline const std::string& MetaData::_internal_examid() const {
  return examid_.Get();
}
inline void MetaData::_internal_set_examid(const std::string& value) {
  
  examid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetaData::_internal_mutable_examid() {
  
  return examid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetaData::release_examid() {
  // @@protoc_insertion_point(field_release:student.MetaData.examId)
  return examid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetaData::set_allocated_examid(std::string* examid) {
  if (examid != nullptr) {
    
  } else {
    
  }
  examid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), examid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:student.MetaData.examId)
}

// -------------------------------------------------------------------

// StreamVideoRequest

// .student.MetaData metadata = 1;
inline bool StreamVideoRequest::_internal_has_metadata() const {
  return request_case() == kMetadata;
}
inline bool StreamVideoRequest::has_metadata() const {
  return _internal_has_metadata();
}
inline void StreamVideoRequest::set_has_metadata() {
  _oneof_case_[0] = kMetadata;
}
inline void StreamVideoRequest::clear_metadata() {
  if (_internal_has_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.metadata_;
    }
    clear_has_request();
  }
}
inline ::student::MetaData* StreamVideoRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:student.StreamVideoRequest.metadata)
  if (_internal_has_metadata()) {
    clear_has_request();
      ::student::MetaData* temp = request_.metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::student::MetaData& StreamVideoRequest::_internal_metadata() const {
  return _internal_has_metadata()
      ? *request_.metadata_
      : reinterpret_cast< ::student::MetaData&>(::student::_MetaData_default_instance_);
}
inline const ::student::MetaData& StreamVideoRequest::metadata() const {
  // @@protoc_insertion_point(field_get:student.StreamVideoRequest.metadata)
  return _internal_metadata();
}
inline ::student::MetaData* StreamVideoRequest::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:student.StreamVideoRequest.metadata)
  if (_internal_has_metadata()) {
    clear_has_request();
    ::student::MetaData* temp = request_.metadata_;
    request_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamVideoRequest::unsafe_arena_set_allocated_metadata(::student::MetaData* metadata) {
  clear_request();
  if (metadata) {
    set_has_metadata();
    request_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:student.StreamVideoRequest.metadata)
}
inline ::student::MetaData* StreamVideoRequest::_internal_mutable_metadata() {
  if (!_internal_has_metadata()) {
    clear_request();
    set_has_metadata();
    request_.metadata_ = CreateMaybeMessage< ::student::MetaData >(GetArenaForAllocation());
  }
  return request_.metadata_;
}
inline ::student::MetaData* StreamVideoRequest::mutable_metadata() {
  ::student::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:student.StreamVideoRequest.metadata)
  return _msg;
}

// bytes chunkdata = 2;
inline bool StreamVideoRequest::_internal_has_chunkdata() const {
  return request_case() == kChunkdata;
}
inline bool StreamVideoRequest::has_chunkdata() const {
  return _internal_has_chunkdata();
}
inline void StreamVideoRequest::set_has_chunkdata() {
  _oneof_case_[0] = kChunkdata;
}
inline void StreamVideoRequest::clear_chunkdata() {
  if (_internal_has_chunkdata()) {
    request_.chunkdata_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_request();
  }
}
inline const std::string& StreamVideoRequest::chunkdata() const {
  // @@protoc_insertion_point(field_get:student.StreamVideoRequest.chunkdata)
  return _internal_chunkdata();
}
template <typename ArgT0, typename... ArgT>
inline void StreamVideoRequest::set_chunkdata(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_chunkdata()) {
    clear_request();
    set_has_chunkdata();
    request_.chunkdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_.chunkdata_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:student.StreamVideoRequest.chunkdata)
}
inline std::string* StreamVideoRequest::mutable_chunkdata() {
  std::string* _s = _internal_mutable_chunkdata();
  // @@protoc_insertion_point(field_mutable:student.StreamVideoRequest.chunkdata)
  return _s;
}
inline const std::string& StreamVideoRequest::_internal_chunkdata() const {
  if (_internal_has_chunkdata()) {
    return request_.chunkdata_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StreamVideoRequest::_internal_set_chunkdata(const std::string& value) {
  if (!_internal_has_chunkdata()) {
    clear_request();
    set_has_chunkdata();
    request_.chunkdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  request_.chunkdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamVideoRequest::_internal_mutable_chunkdata() {
  if (!_internal_has_chunkdata()) {
    clear_request();
    set_has_chunkdata();
    request_.chunkdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return request_.chunkdata_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamVideoRequest::release_chunkdata() {
  // @@protoc_insertion_point(field_release:student.StreamVideoRequest.chunkdata)
  if (_internal_has_chunkdata()) {
    clear_has_request();
    return request_.chunkdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void StreamVideoRequest::set_allocated_chunkdata(std::string* chunkdata) {
  if (has_request()) {
    clear_request();
  }
  if (chunkdata != nullptr) {
    set_has_chunkdata();
    request_.chunkdata_.UnsafeSetDefault(chunkdata);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(chunkdata);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:student.StreamVideoRequest.chunkdata)
}

inline bool StreamVideoRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void StreamVideoRequest::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline StreamVideoRequest::RequestCase StreamVideoRequest::request_case() const {
  return StreamVideoRequest::RequestCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace student

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_student_2eproto
